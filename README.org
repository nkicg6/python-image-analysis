#+TITLE: Python functions for figures and analysis
#+DATE: 2017-09-07
#+OPTIONS: toc:nil author:nil title:nil date:nil num:nil ^:{} \n:1 todo:nil
#+PROPERTY: header-args :exports both :eval no-export :tangle imageanalysis.py
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
#+LATEX_HEADER: \hypersetup{citecolor=black,colorlinks=true,urlcolor=blue,linkbordercolor=blue,pdfborderstyle={/S/U/W 1}}
#+LATEX_HEADER: \usepackage[round]{natbib}
#+LATEX_HEADER: \renewcommand{\bibsection}

This document is a work in progress and contains useful python functions I have discovered or written to aid in image analysis of microscopy data and making figures for presentations. Most of my work is done in python or R and I use Emacs [[http://orgmode.org/][Org-mode]] for [[http://www.literateprogramming.com/knuthweb.pdf][literate programming]]. 
My goal for writing scientific papers is to work in org-mode and have all my figures generated programmatically when the document compiles to PDF. This makes the work more reproducible and easier to work with. I will be adding to this document as I work and learn. Most of it will not be org-mode specific, except where indicated. 

This document is [[http://orgmode.org/manual/Extracting-source-code.html][tangled]] into the accompanying python source doc in the repo and can be downloaded and used freely.

When my workflow is more mature, I plan on integrating these functions into a class.

Suggestions and contributions welcome!
* Links and resources
Here is a collection of links and resources I have come across. 
- [[http://scikit-image.org/docs/dev/auto_examples/index.html][Scikit image tutorials]] are excellent. This is one of the best resources I have found.
  - Long walk through of [[http://scikit-image.org/docs/dev/auto_examples/xx_applications/plot_morphology.html#sphx-glr-auto-examples-xx-applications-plot-morphology-py][morphological filtering]] is especially useful.
- [[https://github.com/scikit-image/skimage-tutorials/blob/3f991ba579b04fdf893654d3fe725a6b736bce2a/lectures/three_dimensional_image_processing.ipynb][Excellent skimage 3D analysis]] tutorial. 
- The [[https://github.com/scikit-image/skimage-tutorials/blob/3f991ba579b04fdf893654d3fe725a6b736bce2a/lectures/three_dimensional_image_processing.ipynb][scikit-image]] github page contains some excellent tutorials you can walk though as well.
- A professor at Caltech has some excellent lecture [[http://bi1x.caltech.edu/2015/tutorials/image_processing_1.html][online]] focused on segmenting bacteria from images.
  - [[http://bi1x.caltech.edu/2015/tutorials/image_processing_2.html][Part 2]]
  - Other [[http://bi1x.caltech.edu/2015/handouts.html][modules]] from the course
  - Cool [[http://bi1x.caltech.edu/2015/tutorials/intro_to_python.html][intro to python]]
* Making figures

** Basics

The first step is to read images. For this, we use a python wrapper around the [[https://www.openmicroscopy.org/bio-formats/][OME Bioformats]] command line tool [[https://docs.openmicroscopy.org/bio-formats/5.7.0/users/comlinetools/index.html][bfconvert]]. I wrote a python wrapper around bfconvert that will convert images or directories and store them in a dedicated folder for easier use and organization. This script and the documentation is [[https://github.com/nkicg6/tif-convert][available on github]]. 

Next, images are read in using skimage like so 

#+BEGIN_SRC python :results output
  import skimage.io
  from skimage import img_as_float

  def read_img(path, asfloat=True):
      img = skimage.io.imread(path)
      if not asfloat:
          return img
      img = img_as_float(img)
      return img

#+END_SRC

Typically, images are read asfloat, as skimage operations are performed on floating point. 

** Parse metadata
   
Images are converted to [[https://www.openmicroscopy.org/][OME-Tiff]] format because this is an open source data format that preserves all metadata and can be opened by virtually any image reader. The following function will uses the =tifffile= library to read the image metadata from the first page of the tiff file. 

#+NAME: Parse metadata
#+BEGIN_SRC python :results output


  import re
  import tifffile
  import xml.etree.ElementTree as ET


  def metadata(path):
      """accepts the path to an ome-tif file, or imageJ tif file.
      Attempts to validates image dimensions, returns pixel size 
      and units
      following ome-tif xml schema:
      http://www.openmicroscopy.org/Schemas/OME/2016-06"""
      try:
          with tifffile.TiffFile(path) as tif:
              if tif.is_ome:
                  raw_metadata = tif[0].image_description
                  parse = ET.fromstring(raw_metadata)
                  pixels = parse.find('.//{http://www.openmicroscopy.org/Schemas/OME/2016-06}Pixels')
                  # ensure all pixel units are the same
                  assert pixels.get('PhysicalSizeXUnit') == pixels.get('PhysicalSizeZUnit') == \
                  pixels.get('PhysicalSizeYUnit')
                  units = pixels.get('PhysicalSizeXUnit')
                  assert pixels.get('PhysicalSizeY') == pixels.get('PhysicalSizeX')
                  # save pixel size
                  size = pixels.get('PhysicalSizeY')
                  # Z can be easily implemented (pizels.get(PhysicalSizeZ))
                  return float(size), units
              else:
                  # hopefully it is imagej format
                  raw_metadata = tif[0]
                  # ensure xy pixels are the same size
                  assert raw_metadata.x_resolution == raw_metadata.y_resolution
                  # imageJ encodes as 'pixels per micron' so we should convert back
                  size = 1/(raw_metadata.y_resolution[0]/raw_metadata.y_resolution[-1])
                  check_units = raw_metadata.image_description.decode('utf-8')
                  # regex to search for units. 
                  regex_check = re.search('(?<=unit=)\w+',check_units)
                  if regex_check.group(0) == 'micron':
                      # If micron, return Unicode micron
                      units = '\xb5m'
                      return float(size), units
                  else:
                      return 'Could not determine pixel size. expected micron \
                      got >> {}'.format(regex_check.group(0))
      except AssertionError:
          print("Image dimensions or units do not match")
      except ValueError as e:
          print("Incompatible format >>> {}".format(e))
      except Exception as x:
          print("Error. >>> {}".format(x))

#+END_SRC

I recently updated this function to also parse ImageJ encoded tifs. When you save a tif from imageJ, it encodes only the essential info in the file. By parsing the tif as explained in the [[https://pypi.python.org/pypi/tifffile/0.4][documentation]] like so:

#+BEGIN_SRC python :results output


  import tifffile  
  neun_path_example = '/Volumes/EXTENSION/RESTREPOLAB/images/neuronavigation/macklin_zeiss/2017-08-01/figures/MAX_2017-08-01_H001-017_img006.tif'
  with tifffile.TiffFile(neun_path_example) as tif:
      images = tif.asarray()
      for page in tif:
          for tag in page.tags.values():
              t = tag.name, tag.value
              print(t)

#+END_SRC

#+RESULTS:
#+begin_example
('new_subfile_type', 0)
('image_width', 2048)
('image_length', 2048)
('bits_per_sample', 16)
('photometric', 1)
('image_description', b'ImageJ=1.51n\nimages=2\nchannels=2\nmode=grayscale\nunit=micron\nspacing=5.0\nloop=false\nmin=348.0\nmax=2437.0\n')
('strip_offsets', (367,))
('samples_per_pixel', 1)
('rows_per_strip', 2048)
('strip_byte_counts', (16777216,))
('x_resolution', (769230, 1000000))
('y_resolution', (769230, 1000000))
('resolution_unit', 1)
('imagej_byte_counts', (12, 32))
('imagej_metadata', b'IJIJrang\x00\x00\x00\x01@u\xc0\x00\x00\x00\x00\x00@\xa3\n\x00\x00\x00\x00\x00@o \x00\x00\x00\x00\x00@\xa2r\x00\x00\x00\x00\x00')
#+end_example

You see a different set of results. So in ome-tif files, all the metadata is a xml blob in the =image_description= tag, while in a ImageJ encoded tif, you have to extract it from a series of top level tags. It turns out that these tags exist in the ome-tif ones too, but I think the xml is better to stick with if it is available. Also, it is important to note how ImageJ encodes resolution. It seems to encode a float as a tuple (divide tuple[0] by tuple[-1] for the float) and furthermore this number is =units/pixel=. very weird. I take the inverse to fix it. The imageJ parsing is less robust and informative, but it works. I think =spacing= in =image_description= refers to z-step size but I am not sure. Anyways this seems to work for parsing two tif encoding formats. 

** add scalebar

use the [[https://pypi.python.org/pypi/matplotlib-scalebar][matplotlib-scalebar]] class. Here are some common arguments I like.

#+NAME: scalebar class
#+BEGIN_SRC python :results output


  import matplotlib.pyplot as plt
  from matplotlib_scalebar.scalebar import ScaleBar

  scalebar = ScaleBar(pixelLength, units, location = 'lower right', 
                     fixed_value = 25, color = 'black', frameon = False)
#+END_SRC

Here is a function to use it in a figure. 

#+NAME: Image with scalebar
#+BEGIN_SRC python :results output


  def scale_plot(img, imageSize, scale, units, color):
      plt.figure(figsize=imageSize)
      plt.imshow(img)
      plt.axis('off')
      scalebar = ScaleBar(scale, units, location = 'lower right', 
                          fixed_value = 25, color = color, frameon = False)
      plt.gca().add_artist(scalebar)
#+END_SRC

** Subplots

The following format works well for splitting two channels and merging. 

#+BEGIN_SRC python :results output


import matplotlib.pyplot as plt

f, (ax1,ax2,ax3) = plt.subplots(1,3, figsize=(10,10))
ax1.imshow(trans[300:,:], cmap='gray')
ax1.axis('off')
ax1.set_title('Transmitted',size=15)
ax2.imshow(auto[300:,:])
ax2.set_title('Autofluorescense',size=15)
ax2.axis('off')
ax3.imshow(auto[300:,:])
ax3.imshow(trans[300:,:], alpha = 0.46,cmap='gray')
ax3.set_title('Merge', size=15)
ax3.axis('off')
plt.tight_layout()
#+END_SRC


more to come...

* Analysis

Interactive line profiles are cool!

#+NAME: Interactive line profiles
#+BEGIN_SRC python :results output
  import matplotlib
  matplotlib.use('TKAgg') # I don't have matplotlib installed as a framework so I need this..
  from skimage import data
  from skimage.viewer import ImageViewer
  from skimage.viewer.plugins.lineprofile import LineProfile

  def make_profile(image):
      """ 
      Takes a 2D image, gives an PyQt image
      viewer that you can make a ROI on. 
      returns line profile values
      """
      viewer = ImageViewer(image)
      viewer += LineProfile()
      _, line = zip(*viewer.show())
      return line

#+END_SRC

Dray your profile line then close the image. This returns a list of length 1 containing a tuple. The tuple contains the image array and the line profile. Very annoying, but I used argument unpacking with zip(*args) to fix it. I used the tutorial and put them in a function. 




